/**
 * a generic 2d array of data
 */
export class Grid {
    constructor(width = 0, height = 0, data, offset = 0, rowPitch = 0) {
        this.width = width;
        this.height = height;
        this.data = data;
        this.offset = offset;
        this.rowPitch = rowPitch;
        // check for errors
        if (this.rowPitch === 0) {
            this.rowPitch = this.width;
        }
        const maxOffset = this.offset + this.rowPitch * this.height;
        if (maxOffset > this.data.length) {
            throw new Error(`Max offset of ${maxOffset} is greater than length of data array - ${this.data.length}`);
        }
    }
    assertBounds(x, y) {
        if (x < 0 || x >= this.width) {
            throw new Error(`${x} x-coordinate is out of bounds, must be between 0 and ${this.width - 1}`);
        }
        if (y < 0 || y >= this.height) {
            throw new Error(`${y} y-coordinate is out of bounds, must be between 0 and ${this.height - 1}`);
        }
    }
    inBounds(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height;
    }
    regionInBounds(x, y, width, height) {
        return this.inBounds(x, y) && this.inBounds(x + width - 1, y + height - 1);
    }
    rectInBounds(rect) {
        return this.regionInBounds(rect.x, rect.y, rect.width, rect.height);
    }
    /**
     * return flattened index for specified coordinates
     * @param x x coord
     * @param y y coord
     */
    flat(x, y) {
        this.assertBounds(x, y);
        const i = this.offset + y * this.rowPitch + x;
        return i;
    }
    /**
     * return flattened index for coordinates
     * @param xy coordinates to flatten
     */
    flatCoords(xy) {
        const [x, y] = xy;
        return this.flat(x, y);
    }
    /**
     * return item at specified "flat" index
     * @param i flat coordinate to access item at
     */
    atf(i) {
        const item = this.data[i];
        return item;
    }
    /**
     * access item at specified coordinates
     * @param x x coordinate
     * @param y y coordinate
     */
    at(x, y) {
        const i = this.flat(x, y);
        const item = this.atf(i);
        return item;
    }
    /**
     * access item at specified coordinates
     * @param xy coordinates to access
     */
    atCoords(xy) {
        const [x, y] = xy;
        return this.at(x, y);
    }
    /**
     * set item at specified flat index to specified value
     * @param i flat index of item
     * @param value value
     */
    setf(i, value) {
        this.data[i] = value;
    }
    /**
     * set item at specified coordinates to specified value
     * @param x x coordinate
     * @param y y coordinate
     * @param value value to set
     */
    set(x, y, value) {
        this.setf(this.flat(x, y), value);
    }
    /**
     * set item at specified coordinates to specified value
     * @param xy coords
     * @param value value to set
     */
    setCoords(xy, value) {
        const [x, y] = xy;
        this.set(x, y, value);
    }
    /**
     * scan the specified region of the array
     * @param x0 x coord
     * @param y0 y coord
     * @param width width of scan region
     * @param height height of scan region
     * @param f function to call for each x/y coordinate
     */
    *scanRegion(x0, y0, width, height) {
        const r = x0 + width;
        const b = y0 + height;
        for (let y = y0; y < b; ++y) {
            for (let x = x0; x < r; ++x) {
                yield [x, y, this.at(x, y)];
            }
        }
    }
    /**
     * scan the specified region of the array
     * @param rect rect containing area to scan
     * @param f function to call for each x/y coordinate
     */
    scanRect(rect) {
        return this.scanRegion(rect.x, rect.y, rect.width, rect.height);
    }
    /**
     * scan the entire grid
     * @param f function to call for each x/y coordinate
     */
    scan() {
        return this.scanRegion(0, 0, this.width, this.height);
    }
    /**
     * iterate over all things in grid
     */
    *[Symbol.iterator]() {
        for (const x of this.data) {
            yield x;
        }
    }
    /**
     * iterate over a specified region
     */
    *iterRegion(x0, y0, width, height) {
        const r = x0 + width;
        const b = y0 + height;
        for (let x = x0; x < r; ++x) {
            for (let y = y0; y < b; ++y) {
                yield this.at(x, y);
            }
        }
    }
    /**
    * iterate over a specified region
    */
    iterRect(rect) {
        return this.iterRegion(rect.x, rect.y, rect.width, rect.height);
    }
    /**
     * copy a portion of this grid into a new grid
     */
    view(x, y, width, height) {
        const offset = this.flat(x, y);
        const dst = new Grid(width, height, this.data, offset, this.rowPitch);
        return dst;
    }
    /**
     * construct a new grid by applying a function to every element in this grid
     * @param f mapping function
     */
    map(f) {
        const data = [];
        for (let y = 0; y < this.height; ++y) {
            for (let x = 0; x < this.width; ++x) {
                const v = this.at(x, y);
                data.push(f(v, x, y));
            }
        }
        return new Grid(this.width, this.height, data);
    }
    /**
     * find the coordinates of an element in the grid that meets the specified criteria
     * @param f predicate function
     */
    findCoords(f) {
        for (let y = 0; y < this.height; ++y) {
            for (let x = 0; x < this.width; ++x) {
                const v = this.at(x, y);
                if (f(v)) {
                    return [x, y];
                }
            }
        }
        return null;
    }
}
/**
 * copy source grid to destination grid
 * @param src source grid
 * @param dst destination grid
 * @param x destination x offset
 * @param y destination y offset
 */
export function copy(src, dst, dx, dy) {
    for (const [x, y, v] of src.scan()) {
        dst.set(x + dx, y + dy, v);
    }
}
/**
 * copy a region of grid to subgrid
 * @param src source grid
 * @param sx source x offset
 * @param sy source y offset
 * @param width width of region
 * @param height height of region
 * @param dst destination grid
 * @param dx destination x offset
 * @param dy destination y offset
 */
export function copyRegion(src, sx, sy, width, height, dst, dx, dy) {
    for (const [x, y, v] of src.scanRegion(sx, sy, width, height)) {
        dst.set(x + dx, y + dy, v);
    }
}
export function generate(width, height, f) {
    const data = [];
    for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
            data.push(f(x, y));
        }
    }
    const grd = new Grid(width, height, data);
    return grd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdyaWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZUE7O0dBRUc7QUFDSCxNQUFNLE9BQU8sSUFBSTtJQUNiLFlBQXFCLFFBQWdCLENBQUMsRUFBVyxTQUFpQixDQUFDLEVBQVcsSUFBUyxFQUFXLFNBQWlCLENBQUMsRUFBVyxXQUFtQixDQUFDO1FBQTlILFVBQUssR0FBTCxLQUFLLENBQVk7UUFBVyxXQUFNLEdBQU4sTUFBTSxDQUFZO1FBQVcsU0FBSSxHQUFKLElBQUksQ0FBSztRQUFXLFdBQU0sR0FBTixNQUFNLENBQVk7UUFBVyxhQUFRLEdBQVIsUUFBUSxDQUFZO1FBQy9JLG1CQUFtQjtRQUNuQixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQTtTQUM3QjtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFBO1FBQzNELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLFNBQVMsMkNBQTJDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQTtTQUMzRztJQUNMLENBQUM7SUFFRCxZQUFZLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDN0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLHlEQUF5RCxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUE7U0FDakc7UUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMseURBQXlELElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTtTQUNsRztJQUNMLENBQUM7SUFFRCxRQUFRLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUE7SUFDaEUsQ0FBQztJQUVELGNBQWMsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQWEsRUFBRSxNQUFjO1FBQzlELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFBO0lBQzlFLENBQUM7SUFFRCxZQUFZLENBQUMsSUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ3ZFLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBSSxDQUFDLENBQVMsRUFBRSxDQUFTO1FBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQ3ZCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFBO1FBQzdDLE9BQU8sQ0FBQyxDQUFBO0lBQ1osQ0FBQztJQUVEOzs7T0FHRztJQUNILFVBQVUsQ0FBQyxFQUFVO1FBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEdBQUcsQ0FBQyxDQUFTO1FBQ1QsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUN6QixPQUFPLElBQUksQ0FBQTtJQUNmLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsRUFBRSxDQUFDLENBQVMsRUFBRSxDQUFTO1FBQ25CLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQ3pCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDeEIsT0FBTyxJQUFJLENBQUE7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEVBQVU7UUFDZixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUNqQixPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQ3hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBSSxDQUFDLENBQVMsRUFBRSxLQUFRO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFBO0lBQ3hCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQVE7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQVMsQ0FBQyxFQUFVLEVBQUUsS0FBUTtRQUMxQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUNqQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7SUFDekIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxDQUFDLFVBQVUsQ0FBQyxFQUFVLEVBQUUsRUFBVSxFQUFFLEtBQWEsRUFBRSxNQUFjO1FBQzdELE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDcEIsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQTtRQUVyQixLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3pCLEtBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQ3pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7YUFDOUI7U0FDSjtJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsUUFBUSxDQUFDLElBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ25FLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJO1FBQ0EsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7SUFDekQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDZCxLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDdkIsTUFBTSxDQUFDLENBQUE7U0FDVjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILENBQUMsVUFBVSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWM7UUFDN0QsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQTtRQUNwQixNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFBO1FBRXJCLEtBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtnQkFDekIsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTthQUN0QjtTQUNKO0lBQ0wsQ0FBQztJQUVEOztNQUVFO0lBQ0YsUUFBUSxDQUFDLElBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ25FLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQWEsRUFBRSxNQUFjO1FBQ3BELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQzlCLE1BQU0sR0FBRyxHQUFHLElBQUksSUFBSSxDQUFJLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ3hFLE9BQU8sR0FBRyxDQUFBO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILEdBQUcsQ0FBSSxDQUFvQztRQUN2QyxNQUFNLElBQUksR0FBUSxFQUFFLENBQUE7UUFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQ2pDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO2dCQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7YUFDeEI7U0FDSjtRQUVELE9BQU8sSUFBSSxJQUFJLENBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ3JELENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsQ0FBb0I7UUFDM0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQ2pDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDTixPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO2lCQUNoQjthQUNKO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQTtJQUNmLENBQUM7Q0FDSjtBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxJQUFJLENBQUksR0FBWSxFQUFFLEdBQVksRUFBRSxFQUFVLEVBQUUsRUFBVTtJQUN0RSxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNoQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUM3QjtBQUNMLENBQUM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FDdEIsR0FBWSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFDbkUsR0FBWSxFQUFFLEVBQVUsRUFBRSxFQUFVO0lBRXBDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsRUFBRTtRQUMzRCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUM3QjtBQUNMLENBQUM7QUFFRCxNQUFNLFVBQVUsUUFBUSxDQUFJLEtBQWEsRUFBRSxNQUFjLEVBQUUsQ0FBOEI7SUFDckYsTUFBTSxJQUFJLEdBQVEsRUFBRSxDQUFBO0lBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNyQjtLQUNKO0lBRUQsTUFBTSxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUksS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUM1QyxPQUFPLEdBQUcsQ0FBQTtBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQSByZWN0YW5ndWxhciBhcmVhXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJlY3Qge1xyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgd2lkdGg6IG51bWJlcixcclxuICAgIGhlaWdodDogbnVtYmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiAyZCBjb29yZHNcclxuICovXHJcbmV4cG9ydCB0eXBlIENvb3JkcyA9IFtudW1iZXIsIG51bWJlcl1cclxuXHJcbi8qKlxyXG4gKiBhIGdlbmVyaWMgMmQgYXJyYXkgb2YgZGF0YVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyaWQ8VD4ge1xyXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgd2lkdGg6IG51bWJlciA9IDAsIHJlYWRvbmx5IGhlaWdodDogbnVtYmVyID0gMCwgcmVhZG9ubHkgZGF0YTogVFtdLCByZWFkb25seSBvZmZzZXQ6IG51bWJlciA9IDAsIHJlYWRvbmx5IHJvd1BpdGNoOiBudW1iZXIgPSAwKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yc1xyXG4gICAgICAgIGlmICh0aGlzLnJvd1BpdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93UGl0Y2ggPSB0aGlzLndpZHRoXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtYXhPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucm93UGl0Y2ggKiB0aGlzLmhlaWdodFxyXG4gICAgICAgIGlmIChtYXhPZmZzZXQgPiB0aGlzLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWF4IG9mZnNldCBvZiAke21heE9mZnNldH0gaXMgZ3JlYXRlciB0aGFuIGxlbmd0aCBvZiBkYXRhIGFycmF5IC0gJHt0aGlzLmRhdGEubGVuZ3RofWApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydEJvdW5kcyh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh4IDwgMCB8fCB4ID49IHRoaXMud2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3h9IHgtY29vcmRpbmF0ZSBpcyBvdXQgb2YgYm91bmRzLCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLndpZHRoIC0gMX1gKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3l9IHktY29vcmRpbmF0ZSBpcyBvdXQgb2YgYm91bmRzLCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLmhlaWdodCAtIDF9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5Cb3VuZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLndpZHRoICYmIHkgPj0gMCAmJiB5IDwgdGhpcy5oZWlnaHRcclxuICAgIH1cclxuXHJcbiAgICByZWdpb25JbkJvdW5kcyh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbkJvdW5kcyh4LCB5KSAmJiB0aGlzLmluQm91bmRzKHggKyB3aWR0aCAtIDEsIHkgKyBoZWlnaHQgLSAxKVxyXG4gICAgfVxyXG5cclxuICAgIHJlY3RJbkJvdW5kcyhyZWN0OiBSZWN0KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uSW5Cb3VuZHMocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIGZsYXR0ZW5lZCBpbmRleCBmb3Igc3BlY2lmaWVkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0geCB4IGNvb3JkXHJcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkXHJcbiAgICAgKi9cclxuICAgIGZsYXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKHgsIHkpXHJcbiAgICAgICAgY29uc3QgaSA9IHRoaXMub2Zmc2V0ICsgeSAqIHRoaXMucm93UGl0Y2ggKyB4XHJcbiAgICAgICAgcmV0dXJuIGlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiBmbGF0dGVuZWQgaW5kZXggZm9yIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0geHkgY29vcmRpbmF0ZXMgdG8gZmxhdHRlblxyXG4gICAgICovXHJcbiAgICBmbGF0Q29vcmRzKHh5OiBDb29yZHMpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHh5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdCh4LCB5KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIGl0ZW0gYXQgc3BlY2lmaWVkIFwiZmxhdFwiIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaSBmbGF0IGNvb3JkaW5hdGUgdG8gYWNjZXNzIGl0ZW0gYXQgXHJcbiAgICAgKi9cclxuICAgIGF0ZihpOiBudW1iZXIpOiBUIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5kYXRhW2ldXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGFjY2VzcyBpdGVtIGF0IHNwZWNpZmllZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gICAgYXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBUIHtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5mbGF0KHgsIHkpXHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuYXRmKGkpXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGFjY2VzcyBpdGVtIGF0IHNwZWNpZmllZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHh5IGNvb3JkaW5hdGVzIHRvIGFjY2Vzc1xyXG4gICAgICovXHJcbiAgICBhdENvb3Jkcyh4eTogQ29vcmRzKTogVCB7XHJcbiAgICAgICAgY29uc3QgW3gsIHldID0geHlcclxuICAgICAgICByZXR1cm4gdGhpcy5hdCh4LCB5KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGl0ZW0gYXQgc3BlY2lmaWVkIGZsYXQgaW5kZXggdG8gc3BlY2lmaWVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gaSBmbGF0IGluZGV4IG9mIGl0ZW1cclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXRmKGk6IG51bWJlciwgdmFsdWU6IFQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRhdGFbaV0gPSB2YWx1ZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGl0ZW0gYXQgc3BlY2lmaWVkIGNvb3JkaW5hdGVzIHRvIHNwZWNpZmllZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHggeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geSB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBzZXRcclxuICAgICAqL1xyXG4gICAgc2V0KHg6IG51bWJlciwgeTogbnVtYmVyLCB2YWx1ZTogVCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2V0Zih0aGlzLmZsYXQoeCwgeSksIHZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGl0ZW0gYXQgc3BlY2lmaWVkIGNvb3JkaW5hdGVzIHRvIHNwZWNpZmllZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHh5IGNvb3Jkc1xyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHNldFxyXG4gICAgICovXHJcbiAgICBzZXRDb29yZHMoeHk6IENvb3JkcywgdmFsdWU6IFQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbeCwgeV0gPSB4eVxyXG4gICAgICAgIHRoaXMuc2V0KHgsIHksIHZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2NhbiB0aGUgc3BlY2lmaWVkIHJlZ2lvbiBvZiB0aGUgYXJyYXlcclxuICAgICAqIEBwYXJhbSB4MCB4IGNvb3JkXHJcbiAgICAgKiBAcGFyYW0geTAgeSBjb29yZFxyXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHNjYW4gcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGhlaWdodCBvZiBzY2FuIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIGYgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB4L3kgY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICAqc2NhblJlZ2lvbih4MDogbnVtYmVyLCB5MDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEl0ZXJhYmxlPFtudW1iZXIsIG51bWJlciwgVF0+IHtcclxuICAgICAgICBjb25zdCByID0geDAgKyB3aWR0aFxyXG4gICAgICAgIGNvbnN0IGIgPSB5MCArIGhlaWdodFxyXG5cclxuICAgICAgICBmb3IgKGxldCB5ID0geTA7IHkgPCBiOyArK3kpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHgwOyB4IDwgcjsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBbeCwgeSwgdGhpcy5hdCh4LCB5KV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjYW4gdGhlIHNwZWNpZmllZCByZWdpb24gb2YgdGhlIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gcmVjdCByZWN0IGNvbnRhaW5pbmcgYXJlYSB0byBzY2FuXHJcbiAgICAgKiBAcGFyYW0gZiBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHgveSBjb29yZGluYXRlXHJcbiAgICAgKi9cclxuICAgIHNjYW5SZWN0KHJlY3Q6IFJlY3QpOiBJdGVyYWJsZTxbbnVtYmVyLCBudW1iZXIsIFRdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhblJlZ2lvbihyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzY2FuIHRoZSBlbnRpcmUgZ3JpZFxyXG4gICAgICogQHBhcmFtIGYgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB4L3kgY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICBzY2FuKCk6IEl0ZXJhYmxlPFtudW1iZXIsIG51bWJlciwgVF0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FuUmVnaW9uKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaXRlcmF0ZSBvdmVyIGFsbCB0aGluZ3MgaW4gZ3JpZFxyXG4gICAgICovXHJcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICB5aWVsZCB4XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaXRlcmF0ZSBvdmVyIGEgc3BlY2lmaWVkIHJlZ2lvblxyXG4gICAgICovXHJcbiAgICAqaXRlclJlZ2lvbih4MDogbnVtYmVyLCB5MDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHIgPSB4MCArIHdpZHRoXHJcbiAgICAgICAgY29uc3QgYiA9IHkwICsgaGVpZ2h0XHJcblxyXG4gICAgICAgIGZvciAobGV0IHggPSB4MDsgeCA8IHI7ICsreCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0geTA7IHkgPCBiOyArK3kpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYXQoeCwgeSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogaXRlcmF0ZSBvdmVyIGEgc3BlY2lmaWVkIHJlZ2lvblxyXG4gICAgKi9cclxuICAgIGl0ZXJSZWN0KHJlY3Q6IFJlY3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyUmVnaW9uKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvcHkgYSBwb3J0aW9uIG9mIHRoaXMgZ3JpZCBpbnRvIGEgbmV3IGdyaWRcclxuICAgICAqL1xyXG4gICAgdmlldyh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBHcmlkPFQ+IHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmZsYXQoeCwgeSlcclxuICAgICAgICBjb25zdCBkc3QgPSBuZXcgR3JpZDxUPih3aWR0aCwgaGVpZ2h0LCB0aGlzLmRhdGEsIG9mZnNldCwgdGhpcy5yb3dQaXRjaClcclxuICAgICAgICByZXR1cm4gZHN0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjb25zdHJ1Y3QgYSBuZXcgZ3JpZCBieSBhcHBseWluZyBhIGZ1bmN0aW9uIHRvIGV2ZXJ5IGVsZW1lbnQgaW4gdGhpcyBncmlkXHJcbiAgICAgKiBAcGFyYW0gZiBtYXBwaW5nIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIG1hcDxVPihmOiAodjogVCwgeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IFUpOiBHcmlkPFU+IHtcclxuICAgICAgICBjb25zdCBkYXRhOiBVW10gPSBbXVxyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuYXQoeCwgeSlcclxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChmKHYsIHgsIHkpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEdyaWQ8VT4odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGRhdGEpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5kIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IGluIHRoZSBncmlkIHRoYXQgbWVldHMgdGhlIHNwZWNpZmllZCBjcml0ZXJpYVxyXG4gICAgICogQHBhcmFtIGYgcHJlZGljYXRlIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIGZpbmRDb29yZHMoZjogKHY6IFQpID0+IGJvb2xlYW4pOiAoQ29vcmRzIHwgbnVsbCkge1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuYXQoeCwgeSlcclxuICAgICAgICAgICAgICAgIGlmIChmKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogY29weSBzb3VyY2UgZ3JpZCB0byBkZXN0aW5hdGlvbiBncmlkXHJcbiAqIEBwYXJhbSBzcmMgc291cmNlIGdyaWRcclxuICogQHBhcmFtIGRzdCBkZXN0aW5hdGlvbiBncmlkXHJcbiAqIEBwYXJhbSB4IGRlc3RpbmF0aW9uIHggb2Zmc2V0XHJcbiAqIEBwYXJhbSB5IGRlc3RpbmF0aW9uIHkgb2Zmc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weTxUPihzcmM6IEdyaWQ8VD4sIGRzdDogR3JpZDxUPiwgZHg6IG51bWJlciwgZHk6IG51bWJlcikge1xyXG4gICAgZm9yIChjb25zdCBbeCwgeSwgdl0gb2Ygc3JjLnNjYW4oKSkge1xyXG4gICAgICAgIGRzdC5zZXQoeCArIGR4LCB5ICsgZHksIHYpXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjb3B5IGEgcmVnaW9uIG9mIGdyaWQgdG8gc3ViZ3JpZFxyXG4gKiBAcGFyYW0gc3JjIHNvdXJjZSBncmlkXHJcbiAqIEBwYXJhbSBzeCBzb3VyY2UgeCBvZmZzZXRcclxuICogQHBhcmFtIHN5IHNvdXJjZSB5IG9mZnNldFxyXG4gKiBAcGFyYW0gd2lkdGggd2lkdGggb2YgcmVnaW9uXHJcbiAqIEBwYXJhbSBoZWlnaHQgaGVpZ2h0IG9mIHJlZ2lvblxyXG4gKiBAcGFyYW0gZHN0IGRlc3RpbmF0aW9uIGdyaWRcclxuICogQHBhcmFtIGR4IGRlc3RpbmF0aW9uIHggb2Zmc2V0XHJcbiAqIEBwYXJhbSBkeSBkZXN0aW5hdGlvbiB5IG9mZnNldFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZWdpb248VD4oXHJcbiAgICBzcmM6IEdyaWQ8VD4sIHN4OiBudW1iZXIsIHN5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxyXG4gICAgZHN0OiBHcmlkPFQ+LCBkeDogbnVtYmVyLCBkeTogbnVtYmVyKSB7XHJcblxyXG4gICAgZm9yIChjb25zdCBbeCwgeSwgdl0gb2Ygc3JjLnNjYW5SZWdpb24oc3gsIHN5LCB3aWR0aCwgaGVpZ2h0KSkge1xyXG4gICAgICAgIGRzdC5zZXQoeCArIGR4LCB5ICsgZHksIHYpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZTxUPih3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZjogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBUKTogR3JpZDxUPiB7XHJcbiAgICBjb25zdCBkYXRhOiBUW10gPSBbXVxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2goZih4LCB5KSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ3JkID0gbmV3IEdyaWQ8VD4od2lkdGgsIGhlaWdodCwgZGF0YSlcclxuICAgIHJldHVybiBncmRcclxufSJdfQ==